/**
 * Created by pzheng on 6/04/2017.
 */
'use strict';
var ModelDefiner = require('../firebirdModelDefiner.js'),
  config = require('../config/config.js'),
  crypto = require('crypto'),
  helpers = require('../helpers'),
  _ = require('underscore'),
  validator = require('validator'),
  userRoles = require('../config/constants').userRoles,
  async = require('async'),
  UserModel = {};

var UserTable = ModelDefiner.define(config.db, "users");

// could not be recognised by nodejs
/*
 Object.defineProperty(UserModel, "users", {
 get: function() {
 return new Promise(function(resolve, reject) {
 var userTable = new UserTable();
 userTable.find(function(err, results, fields) {
 if(err) { reject(err); }
 else {
 var users=[];
 helpers.wrapJson(results, fields, users);
 resolve(users);
 }
 });
 });
 }
 });
 */
function getUsers(callback) {
  var JsonData = [];
  var userTable = new UserTable();
  userTable.find(function(error, results, fields) {
    if(error) {
      callback(error);
    } else {
      callback(null, results, fields);
    }
  });
}

async.waterfall([getUsers,  helpers.extendWrapJson.bind(helpers)], function(err, result) {
  // console.log('Data in UserModel:', result);
  UserModel.users = _.clone(result) || [];
});

// var users = getUsers();


UserModel = {
  addUser: function ( data, callback) {
    var self = this;
    // Check in the authentication controller
    // if (this.findByUsername(data.username) !== undefined) {
    // return callback("UserAlreadyExists");
    //}

    /*if ( users && users.length > 500) {
     users = this.users.slice(0, 2);
     }
     */
    var salt = helpers.getRandomString(16);
    var password = (function () {
      return self.hashPassword(data.userpass, salt);
    })();
    var content = { // id generated by database rather than the server
      /*id: _.max(users, function (user) {
       return user.id;
       }).id + 1,
       */
      username: data.username,
      userpass: password,
      firstname: data.firstname || "",
      lastname: data.lastname || "",
      email: data.email || "",
      provider: data.provider || "local",
      salt: salt,
      rolegroup: data.rolegroup
    };
    console.log("content", content);
    var userTable = new UserTable(content);
    userTable.save(function(err, results, db) {
      if (results) {
        content.id = Object.keys(results).map(function (key) { //id returned from db
          return results[key];
        })[0];
      }
      if (content.id) {
        console.log(self.users);
        Array.prototype.push.call(self.users, content);
        if (callback) {
          callback(null, content);
        }
      }
      else {
        err = "Fail to get valid id from database";
        if(callback) {
          callback(err, content);
        }
      }
      db.detach();
    });
  },

  updateUser: function(data, callback) {
    var userTable = new UserTable(data);
    userTable.save(callback);
  },

  deleteUser: function(data, callback) {
    var self = this;
    var userTable = new UserTable(data);
    var err;
    if (self.findById(data.id) !== undefined) {
      userTable.remove();
    } else if (self.findByUsername(data.username) !== undefined ) {
      userTable.remove({ where: "username=" + data.username});
    } else {
      err = "Could not find key information to delete user";
    }
    if( callback ) {
      callback(err, data);
    }
  },

  findByProviderId: function (provider, id) {
    return _.find(self.users, function (user) {
      return user[provider] == id;
    });
  },

  validate: function (user) {
    if( !validator.isLength(user.username, {min:1, max:20}) ) {
      throw new Error('Username must be 1-20 characters long');
    }
    if( !validator.isLength(user.userpass, {min:5, max:60}) ) {
      throw new Error('Password must be 5-60 characters long');
    }
    //not matching pattern
    if( validator.matches(user.username, /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=\+\$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=\+\$,\w]+@)[A-Za-z0-9.-]+)((?:\/[\+~%\/.\w-_]*)?\??(?:[-\+=&;%@.\w_]*)#?(?:[\w]*))?)/) ) {
      throw new Error('Invalid user name');
    }
    var stringArr = _.map(_.values(userRoles), function (val) {
      return val.toString();
    });
    if( !validator.isIn(user.rolegroup, stringArr) ) {
      return new Error('Invalid user role');
    }
  },
  // TO-DO
  /*findOrCreateOauthUser: function (provider, providerId) {
   var user = this.findByProviderId(provider, providerId);
   if (!user) {
   user = {
   id: _.max(users, function (user) {
   return user.id;
   }).id + 1,
   username: provider + '_user',
   rolegroup: userRoles.user,
   provider: provider
   };
   user[provider] = providerId;
   users.push(user);
   }
   },
   */

  findAll: function () {
    var self = this;
    return _.map(self.users, function (user) {
      return _.clone(user);
    });
  },

  findById: function (id) {
    var self = this;
    return _.clone(_.find(self.users, function (user) {
      return user.id == id;
    }));
  },

  findByEmail: function(email) {
    var self = this;
    return _.clone(_.find(self.users, function(user) {
      return user.email == email;
    }));
  },

  findByUsername: function (username) {
    var self = this;
    return _.clone(_.find(self.users, function (user) {
      return user.username == username;
    }));
  },

  /*find: function(data) {
   return _.clone(_.find(this.users, function(user) {
   var boolArray = Object.keys(data).map(function(key) { return user[key] === data[key]; });
   return boolArray.every(function(element) { return element == true;});
   }));
   },
   */
  findResetUser: function(token) {
    var self = this;
    return _.clone(_.find(self.users, function(user) {      
      var expires = new Date(user.resetpasswordexpires).getTime();
      var isTokenExpired = expires >= Date.now(); 
      console.log(`expires = ${expires}`);   
      console.log(`Date.now() = ${Date.now()}`);
      return user.resetpasswordtoken == token && isTokenExpired;      
    }));
  },

  authenticate: function (username, password) {
    var self = this;
    var user = self.findByUsername(username);
    if (!user) {
      return false;
    }
    var salt = user.salt;
    var passwordHashed = self.hashPassword(password, salt);
    var passwordStored = user.userpass.toString('utf8');
    return passwordStored == passwordHashed;
  },

  hashPassword: function (password, salt) {
    var passwordData = helpers.sha512(password, salt);
    return passwordData.passwordHash;
  },

  setPasswordTokenAndExpires: function (userObject, token, expires, callback) {
    var self = this;
    var userTable = new UserTable();
    
    var sql = " select id from spw_updateuser(" +
      helpers.parseToFirebirdString(userObject.id, 'number') + "," +
      "null," + // firstname
      "null," + // lastname
      "null," + // email
      "null," + // username
      "null," + // userpass
      "null," + // rolegroup
      "null," + // provider
      "null,"+ // salt
      "null," + //created
      helpers.parseToFirebirdString(token, 'string') + "," + // resetpasswordtoken
      helpers.parseToFirebirdString(expires, 'string') + ")"; // resetpasswordexpires
    console.log('sql', sql);
    // sql = " select * from rdb$database";
    userTable.query(sql, function(error, results, fields) {
      if (error) {
        if (callback) {
          callback(error);
        }
      } else {        
        if (results) { // id == 0, failed
          _.extend(_.findWhere(self.users, {id: userObject.id}), {resetpasswordtoken: token, resetpasswordexpires: expires});
          if (callback) {
            callback(null, userObject);
          }
        }
        else {
          if (callback) {
            var error = { summary: "Error return after executing spw_updateuser" };
            callback(error);
          }
        }
      }
    });
  },

  changePassword: function (userObject, newPassword, callback) {
    var self = this;
    var userTable = new UserTable();

    // new salt and encrypted password
    var newSalt = helpers.getRandomString(16);
    var newPasswordHashed = (function () {
      return self.hashPassword(newPassword, newSalt);
    })();

    var sql = " select id from spw_updateuser(" +
      helpers.parseToFirebirdString(userObject.id, 'number') + "," +
      "null," + // firstname
      "null," + // lastname
      "null," + // email
      "null," + // username
      helpers.parseToFirebirdString(newPasswordHashed, 'string') + "," + // userpass
      "null," + // rolegroup
      "null," + // provider
      "null,"+ // salt
      "null," + //created
      "''" + "," + // resetpasswordtoken
      "''"+ ")"; // resetpasswordexpires
    console.log('sql', sql);
    // sql = " select * from rdb$database";
    userTable.query(sql, function(error, results, fields) {
      if (error) {
        if (callback) {
          callback(error);
        }
      } else {        
        if (results) { // id == 0, failed
          _.extend(_.findWhere(self.users, {id: userObject.id}), {
            resetpasswordtoken: undefined, 
            resetpasswordexpires: undefined,
            userpass: newPasswordHashed,
            salt: newSalt
          });
          if (callback) {
            callback(null, userObject);
          }
        }
        else {
          if (callback) {
            var error = { summary: "Error return after executing spw_updateuser" };
            callback(error);
          }
        }
      }
    });
  },  
}

module.exports = UserModel;
